" Vim config file list:
"     Main: ~wlfwzr/.vim/vimrc
"   Vundle: ~wolfwzr/.vim/vundle.vimrc

let s:W_TRUE  = 1
let s:W_FALSE = 0

let s:W_colorscheme_applied = 0
let s:W_last_filetype = ""
let s:W_last_insert_im_status = 0

let s:W_MarkColorPattern = {}
let s:syn_num = 12
let s:W_last_mark_idx = 12
let s:W_cscope_is_from_symbol = s:W_FALSE

let mapleader=' '

" 辅助函数 {{{
" W_get_visual_selected_text {{{
function! W_get_visual_selected_text()
    " Check if is in visual mode ?
    let l:reg_bakup = @x
    normal gv"xy
    let l:ret = @x
    let @x = l:reg_bakup
    return l:ret
endfunction
"}}}
" W_source: source 一个文件 {{{
function! W_source(file)
    if filereadable(a:file)
        source a:file
        return s:W_TRUE
    endif
    return s:W_FALSE
endfunction
" }}}
" W_exec_cmd: execute an command{{{
function! W_exec_cmd(cmd)
    if exists(a:cmd)
        source a:cmd
        return s:W_TRUE
    endif
    return s:W_FALSE
endfunction
" }}}
" W_eatchar: 吃掉一个字符 {{{
function! W_eatchar(char)
    let c = nr2char(getchar())
    return (c =~ a:char) ? '' : c
endfunction
" }}}
" W_color_modify: 颜色加减运算 {{{
" 正确的实现方法: RGB->HSV,修改V值->RGB
function! W_color_modify(color, oper, modify_value)
    if a:color == ""
        " 返回红色以做告警
        return '#FF0000'
    endif

    if a:oper == 'add'
        let l:col_r = '0x' . strpart(a:color, 1, 2) + a:modify_value
        let l:col_g = '0x' . strpart(a:color, 3, 2) + a:modify_value
        let l:col_b = '0x' . strpart(a:color, 5, 2) + a:modify_value
    elseif a:oper == 'sub'
        let l:col_r = '0x' . strpart(a:color, 1, 2) - a:modify_value
        let l:col_g = '0x' . strpart(a:color, 3, 2) - a:modify_value
        let l:col_b = '0x' . strpart(a:color, 5, 2) - a:modify_value
    elseif a:oper == 'invert'
        let l:col_r = 0xff - ('0x' . strpart(a:color, 1, 2))
        let l:col_g = 0xff - ('0x' . strpart(a:color, 3, 2))
        let l:col_b = 0xff - ('0x' . strpart(a:color, 5, 2))
    else
        echom "W_color_modify: invalid oper"
        return a:color
    endif

    if l:col_r > 0xff | let l:col_r = 0xff | endif
    if l:col_g > 0xff | let l:col_g = 0xff | endif
    if l:col_b > 0xff | let l:col_b = 0xff | endif

    if l:col_r < 0 | let l:col_r = 0 | endif
    if l:col_g < 0 | let l:col_g = 0 | endif
    if l:col_b < 0 | let l:col_b = 0 | endif

    return '#' . printf("%02x", l:col_r)
             \ . printf("%02x", l:col_g)
             \ . printf("%02x", l:col_b)
endfunction
"}}}
" W_winpos_adjust: 调整GVIM窗口坐标 {{{
function! W_winpos_adjust(x_inc, y_inc)
    let l:winpos_x = getwinposx() + a:x_inc
    let l:winpos_y = getwinposy() + a:y_inc
    execute 'winpos '.l:winpos_x.' '.l:winpos_y
endfunction
" }}}
" W_font_review: 临时在vim中预览字体效果 {{{
"用法，先创建一个快捷键Ctrl+Enter来执行当前行命令
" nmap <C-Enter> j$v^<S-Enter>:<S-Enter><CR>
" 再查找出当前系统字体，linux下可运行如下命令：
" fc-list  | awk -F ':' '{print $2}' | sed 's/,/\n/g' | sort | uniq | 
"   sed 's/^ *//g;s/ *$/\ 14/g;s/ /\\ /g;s/^/set guifont=/g' > /tmp/pwall
" 我是通过man -k font,在里面找到fc-list命令的。
function! W_font_review()
    nmap <C-Enter> j$v^<S-Enter>:<S-Enter><CR>

    " 比较好的字体
    set guifont=YaHei\ Consolas\ Hybrid\ 14
    set guifont=Courier\ 10\ Pitch\ 14
    set guifont=Inconsolata\-dz\ for\ Powerline\ 14
    set guifont=Source\ Code\ Pro\ 14
    set guifont=SimSun\ 16

    " 一般的字体
    set guifont=Anonymice\ Powerline\ 15
    set guifont=Anonymous\ Pro\ for\ Powerline\ 15
    set guifont=Inconsolata\ for\ Powerline\ 16
    set guifont=Meslo\ LG\ L\ DZ\ for\ Powerline\ 13
    set guifont=Meslo\ LG\ L\ for\ Powerline\ 13
    set guifont=Meslo\ LG\ M\ DZ\ for\ Powerline\ 13
    set guifont=Meslo\ LG\ M\ for\ Powerline\ 13
    set guifont=Meslo\ LG\ S\ DZ\ for\ Powerline\ 13
    set guifont=Meslo\ LG\ S\ for\ Powerline\ 13
    set guifont=YaHei\ Consolas\ Hybrid\ for\ Powerline\ 14
    set guifont=Adobe\ Courier\ 14
    set guifont=B&H\ LucidaTypewriter\ 13
    set guifont=Bitstream\ Terminal\ 14
    set guifont=Courier\ 14
    set guifont=Droid\ Sans\ Mono\ 14
    set guifont=DejaVu\ Sans\ Mono\ 14
    set guifont=FreeMono\ 14
    set guifont=Liberation\ Mono\ 14
    set guifont=Luxi\ Mono\ 14
    set guifont=Misc\ Fixed\ 15
    set guifont=Sony\ Fixed\ 15
    set guifont=Source\ Code\ Pro\ Black\ 14
    set guifont=Source\ Code\ Pro\ ExtraLight\ 14
    set guifont=Source\ Code\ Pro\ Light\ 14
    set guifont=Source\ Code\ Pro\ Semibold\ 14
    set guifont=Ubuntu\ Mono\ 14
endfunction
"}}}
" W_set_fcitx: Insert/Normal模式切换时自动切换fcitx状态{{{
function! W_set_fcitx(event)
    if a:event == "InsertEnter"
        if s:W_last_insert_im_status == 1       " fcitx is inactive in laststatus
            echom "make fcitx inactive"
            call system("fcitx-remote -c")      " make fcitx inactive
        elseif s:W_last_insert_im_status == 2   " fcitx is active in laststatus
            echom "make fcitx active"
            call system("fcitx-remote -o")      " make fcitx active
        endif
    elseif a:event == "InsertLeave"
        if executable("fcitx-remote")
            let s:W_last_insert_im_status = system("fcitx-remote | tr -d '\r\n'")
        endif
        if s:W_last_insert_im_status == 2       " fcitx is active
            echom "make fcitx inactive"
            call system("fcitx-remote -c")      " inactive fcitx
        endif
    endif
endfunction
"}}}
" W_OpenDirOfCurFile: 打开当前文件所在目录 {{{
function! W_OpenDirOfCurFile()
    call system('xdg-open '.expand('%:p:h'))
endfunction
nnoremap <S-F8> :call W_OpenDirOfCurFile()<CR>
"}}}
" }}}
" 通用函数 {{{
" W_basic_setting: 基础设置 {{{
function! W_basic_setting()
    " 设置显示相对行号，方便jk跳转 "{{{
    set relativenumber
    set number
    "}}}
    " runtimepath管理 "{{{
    set runtimepath-=~wolfwzr/.vim
    set runtimepath+=~wolfwzr/.vim
    set runtimepath-=~wolfwzr/.vim/bundle/Vundle.vim
    set runtimepath+=~wolfwzr/.vim/bundle/Vundle.vim
    "}}}
    " VI兼容性设置 {{{
    set nocp
    " }}}
    " 搜索效果设置 {{{
    set hlsearch
    set incsearch
    " }}}
    " 设置新建窗口时新窗口的位置 {{{
    set splitbelow
    set splitright
    " }}}
    " 退格键设置(设置<BS>可删除的内容） {{{
    set backspace=indent,eol,start
    " }}}
    " 文件编码设置 "{{{
    set encoding=utf-8
    set fileencodings=ucs-bom,utf-8,default,latin1
    "}}}
    " 状态栏设置 {{{
    set laststatus=2   " Always show the statusline
    " 使用powerline代替
    hi StatusLine cterm=bold gui=bold
    set statusline=
        \%f\ %r\ %m\ %q
        \%=
        \[%Y,%{&fileencoding},%{&fileformat}]
        \\ [%l,%02v]\ [%L,%02P]
    " }}}
    " 空格与Tab相关{{{
    " Tab占四个空格的长度
    set ts=4
    " 显示特殊字符（listchars选项所配置的特殊字符）
    set nolist
    " 配置要显示的特殊字符
    set listchars=tab:\|\ ,nbsp:%,trail:-
    " 配置特殊字符显示配色
    " hi SpecialKey ...
    " 醒目显示行尾多余空格
    " match Error /\s\+$/
    " }}}
    " 输入法切换设置{{{
    " 切换到Normal模式时自动使用英文输入法
    " 切换到Insert模式时自动使用上次在Insert模式下使用的输入法
    if has("macunix")
        set noimdisable
    elseif has("unix")
        augroup wolf_fcitxswitch
            au InsertEnter * call W_set_fcitx("InsertEnter")
            au InsertLeave * call W_set_fcitx("InsertLeave")
        augroup end
    endif
    "}}}
    " 鼠标设置{{{
    set mouse=a
    " mousemodel 设置为 popup 时：
    " 单击左键   - 光标跳转
    " 单击右键   - 弹出菜单
    " 拖动左键   - 选择文本
    " 双击左键   - 选择单词
    " Ctrl+左键  - Ctrl+]
    " Ctrl+右键  - Ctrl+t
    " Shift+左键 - 拓展选区
    " Shift+右键 - 搜索单词
    set mousemodel=popup_setpos
    " 可用作 keymap 的鼠标动作
    "
    " ScrollWheel: (help scroll-mouse-wheel)
    " <ScrollWheelUp>
    " <ScrollWheelDown>
    " <ScrollWheelLeft>
    " <ScrollWheelRight>
    "
    " :help <MiddleRelease>
    " code            mouse button               normal action
    " <LeftMouse>     left pressed               set cursor position
    " <LeftDrag>      left moved while pressed   extend selection
    " <LeftRelease>   left released              set selection end
    " <MiddleMouse>   middle pressed             paste text at cursor position
    " <MiddleDrag>    middle moved while pressed -
    " <MiddleRelease> middle released            -
    " <RightMouse>    right pressed              extend selection
    " <RightDrag>     right moved while pressed  extend selection
    " <RightRelease>  right released             set selection end

    " double click
    nmap <2-LeftMouse> <Leader>m

    nmap <S-ScrollWheelUp>   <C-o>
    nmap <S-ScrollWheelDown> <C-i>

    " Auto copy on select
    "vnoremap <LeftRelease> "+ygv<LeftRelease>
    "vnoremap v             "+y
    "set go+=P

    "}}}
    " 杂项设置{{{
    set wrap
    " 取消CursorLine
    " 因为我喜欢CursorLine有淡淡的背景色，但这样会有两个问题：
    "   1. 当前行被 mark.vim 加背景色的单词背景变全黑，非常难看
    "   2. 影响VIM效率
    " 因此取消了CursorLine
    "set nocursorline
    set cursorline
    " }}}
endfunction
" }}}
" W_shortcut_setting: 快捷键设置 {{{
function! W_shortcut_setting()
    " {}()跳转 {{{
    "   跳到上一个或下一个位于行首的{或}
    "   [[ 跳到上一个位于行首的{（默认行为）
    "   [] 跳到上一个位于行首的}（默认行为）
    "   ][ 跳到下一个位于行首的{（默认行为）
    "   ]] 跳到下一个位于行首的}（默认行为）
    " 补充：
    " 当光标在一个{}块内部时:
    "   [{ 上跳到{处（默认行为）
    "   ]} 下跳到}处（默认行为）
    " 当光标在一个()块内部时:
    "   [( 上跳到(处（默认行为）
    "   ]) 下跳到)处（默认行为）
    " 当光标在一个{}/()/[]的一边上时:
    "   % 跳到另一边（默认行为）
    " }}}
    " Buffer/Tab/Window/GUI窗口相关{{{
    if has("gui_running")
        " Tab
        nnoremap <C-j>     gt
        nnoremap <C-k>     gT
        nnoremap <Leader>1 :tabnext 1<CR>
        nnoremap <Leader>2 :tabnext 2<CR>
        nnoremap <Leader>3 :tabnext 3<CR>
        nnoremap <Leader>4 :tabnext 4<CR>
        nnoremap <Leader>5 :tabnext 5<CR>
        nnoremap <Leader>6 :tabnext 6<CR>
        nnoremap <Leader>7 :tabnext 7<CR>
        nnoremap <Leader>8 :tabnext 8<CR>
        nnoremap <Leader>9 :tabnext 9<CR>
        "nnoremap <Leader>T :tabnew<CR>
        " Windows
        "nnoremap <Leader>j <C-w>j
        "nnoremap <Leader>k <C-w>k
        "nnoremap <Leader>h <C-w>h
        "nnoremap <Leader>l <C-w>l
        " Buffer
        "nmap <Leader><Leader>   :ls<CR>:b! 
        nmap <Leader><Leader>   :CtrlPBuffer<CR>
        nnoremap <Leader>p      :bprev!<CR>
        nnoremap <Leader>n      :bnext!<CR>
        nnoremap <Leader><Del>  :bdelete! %<CR>
        nnoremap <C-n>          :enew!<CR>i
    endif
    " }}}
    " 复制/剪切/粘贴 {{{
    if has("gui_running")
        " copy
        vnoremap <C-c> "+y
        vnoremap Y     "+y
        " cut
        vnoremap <C-x> "+x
        vnoremap X     "+x
        " paste
        cnoremap <C-v> <C-r>+
        inoremap <C-v> <C-r>+
        inoremap <C-S-v> <Space><BS><Esc>:set paste<CR>a<C-R>+<Esc>:set nopaste<CR>a
    endif
    " }}}
    " 以 root 权限保存文件 {{{
    command! W :execute ':silent w !sudo tee % > /dev/null' | :edit!
    " }}}
    " 代码折叠快捷键 {{{
    " zi : set foldenable!
    " za : toggle fold
    " zo : open fold
    " zc : close fold
    " nnoremap <Leader><SPACE> @=((foldclosed(line('.'))<0)?'zc':'zo')<CR>
    " nnoremap <Leader><SPACE> za
    " }}}
    " 查看当前光标下单词的帮助信息 {{{
    " 单词字典查询 {{{
    command! -nargs=1 Sdcv call W_dict_qurey("<args>")
    nnoremap <Leader>d :Sdcv '<C-R>=expand("<cword>")<CR>'<CR>
    " }}}
    " Buffer Grep {{{
    " 在当前Buffer中Grep
    "nnoremap <Leader>g :g/\<<C-R>=expand("<cword>")<CR>\>/p<CR>
    "vnoremap <Leader>g :<C-u>g/<C-R>=W_get_visual_selected_text()<CR>/p<CR>
    nnoremap <Leader>g :call W_grep('\<<C-R>=expand("<cword>")<CR>\>')<CR>
    vnoremap <Leader>g :<C-u>call W_grep('<C-R>=W_get_visual_selected_text()<CR>')<CR>
    command! -nargs=1 Grep call W_grep("<args>")
    nnoremap <Leader>/ :Grep 

    " 在所有Buffer中Grep
    " nnoremap <Leader>G :Bgrep <C-R>=expand("<cword>")<CR><CR>
    nnoremap <Leader>G :Ack <C-R>=expand("<cword>")<CR><CR>
    " }}}
    " }}}
    " cmdline模式下的光标移动 {{{
    if has("gui_running")
        " Tips:
        "
        " C-d : Show available completion
        " C-f : go to command line window
        "
        " C-i : <Tab>
        " C-n : <Tab> else <Down>
        " C-p : <S-Tab> else <Up>
        "
        " C-h : backspace
        " C-u : delete whole line
        " C-w : delete one word
        "
        " C-b : cursor to Begin of command-line
        " C-e : cursor to End of command-line

        cnoremap <C-j> <Right>
        cnoremap <C-k> <Left>
        cnoremap <C-l> <Del>
    endif
    " }}}
    " Edit/Source vimrc{{{
    command! EditRc   :tabnew ~wolfwzr/.vim/vimrc
    command! SourceRc :source ~wolfwzr/.vim/vimrc
    "}}}
    " Mark 当前单词 {{{
    nmap <Leader>m :call W_mark(expand("<cword>"), 1)<CR>
    vmap <Leader>m :call W_mark(W_get_visual_selected_text(), 0)<CR>
    "nmap <Leader>m :call MultipleSearch#MultipleSearch(0, expand("<cword>"))<CR>
    "vmap <Leader>m :call MultipleSearch#MultipleSearch(0, W_get_visual_selected_text())<CR>
    "}}}
    " 删除当前 buffer {{{
    nmap <Leader><BS> :bdelete %<CR>
    "}}}
    " 其它 {{{
    nmap <Leader>c :echo synIDattr(synID(line("."), col("."), 1), "name")<CR>

    " 快速预览当前光标下的 ColorScheme
    "noremap <Leader>C :color <C-r>=expand("<cWORD>")<CR><CR>

    " 自动调整窗口大小
    nmap <Leader><Return> :call W_auto_set_window_size()<CR>:silent !center-current-window.sh<CR>

    "nmap <Leader>r :! 
    nmap <Leader>w :w<CR>
    nmap <Leader>q :q<CR>
    nmap <Leader>z :qa!<CR>

    " 查看QuickFix List的上一项/下一项
    " Tips:
    "   :colder 查看上一个quickfix窗口
    "   :cnewer 查看下一个quickfix窗口
    nnoremap <F2>   :belowright copen<CR>
    nnoremap <F3>   :cprev<CR>
    nnoremap <F4>   :cnext<CR>

    nnoremap <S-F2> :cclose<CR>
    nnoremap <S-F3> :colder<CR>
    nnoremap <S-F4> :cnewer<CR>

    "如果带数字进行上下移动，如5j, 5k，则保留原有jk
    "否则使用gj/gk代替
    noremap <silent> <expr> j (v:count == 0 ? 'gj' : 'j')
    noremap <silent> <expr> k (v:count == 0 ? 'gk' : 'k')

    " 插入模式下Esc快速返回命令模式
    augroup FastEsc
        autocmd InsertEnter * set timeoutlen=50
        autocmd InsertLeave * set timeoutlen=1000
    augroup end

    nnoremap <C-e> 5<C-e>
    nnoremap <C-y> 5<C-y>

    "}}}
endfunction
" }}}
" W_gui_setting: GUI设置 {{{
function! W_gui_setting()
    if !has("gui_running")
        return
    endif

    " 去掉菜单栏、工具栏等
    set go=

    " 显示GUI标签栏（与字符界面的标签不同）
    "   - 字符界面的标签可通过set tabline来定制
    "   - GUI 界面的标签可通过set guitablabel来定制
    "   - 语法参考 statusline
    set go+=e
    set guitablabel=%m%N:\ %t
    "在/usr/local/Cellar/macvim/7.4-88/MacVim.app/Contents/Resources/vim/gvimrc
    "文件中将重写guitablabel

    " 自动复制选区
    set go+=P

    " 设置窗口位置和大小
    "    winpos 120 0
    "set columns=108
    "set lines=32
    call W_auto_set_window_size()

    " 设置默认配色方案
    if s:W_colorscheme_applied == 0
        "set background=light
        "call W_set_colorscheme("colorzone")
        set background=dark
        call W_set_colorscheme("solarized")
        "call W_set_colorscheme("tango2")
    endif

    " 光标设置 (:help 'guicursor')
    set guicursor=n-v-c:block-Cursor/lCursor
    set guicursor+=ve:ver35-Cursor
    set guicursor+=o:hor50-Cursor
    set guicursor+=i-ci:ver25-Cursor/lCursor
    set guicursor+=r-cr:hor20-Cursor/lCursor
    set guicursor+=sm:block-Cursor
    set guicursor+=a:blinkon0

    "鼠标设置 （:help 'mouseshape'）
    "指定鼠标在选择文本时的形状
    "   beam: I形鼠标
    "   pencil: 铅笔形状鼠标
    set mouseshape+=n:beam,v:beam

    "右键菜单
    aunmenu PopUp.Select\ Word
    aunmenu PopUp.Select\ Sentence
    aunmenu PopUp.Select\ Paragraph
    aunmenu PopUp.Select\ Line
    aunmenu PopUp.Select\ Block

    amenu   PopUp.-Oper- :
    amenu   PopUp.&Back             <Leader>b
    amenu   PopUp.&Highlight        <Leader>m
    amenu   PopUp.-Goto- :
    amenu   PopUp.Goto\ &Define     <CR>
    amenu   PopUp.Goto\ &References <Leader>fs
    amenu   PopUp.Goto\ &Caller     <Leader>fc

    if has("macunix")
        "set guifont=Monaco\ for\ Powerline:h16,Monaco:h16
        set guifont=Monaco:h15
        " 单独设置中文字体
        " 备用字体
        " Hannotate\ SC\ Regular
        " Libian\ SC\ Regular
        " Yuanti\ SC\ Regular
        " Xingkai\ SC\ Light
        set guifontwide=Kaiti\ SC\ Regular
    else
        "YaHei Consolas Hybrid字体不知为何会使powerline的状态栏占用命令栏
        "set guifont=YaHei\ Consolas\ Hybrid\ 12
        "set guifont=Source\ Code\ Pro\ 12
        "set guifont=Courier\ 10\ Pitch\ 13
        " Monaco + YaHei
        set guifont=Microsoft\ YaHei\ 11
        " 单独设置中文字体
        set guifontwide=PingFang\ SC\ 11
    endif
endfunction
"}}}
" W_common_replace: 通用自动替换 {{{
function! W_common_replace()
    "iabbrev ( ()<Left><C-r>=W_eatchar(')')<CR>
    "iabbrev [ []<Left><C-r>=W_eatchar(']')<CR>
    "iabbrev { {<CR>}<Esc>%a

    inoremap " ""<Left>
    inoremap ' ''<Left>
    inoremap ` ``<Left>
    inoremap ( ()<Left>
    inoremap [ []<Left>
    inoremap { {}<Left>
    inoremap <C-l> <Right>
endfunction
" }}}
" W_set_colorscheme: 设置配色方案 {{{
function! W_set_colorscheme(color)
    if ! has("gui_running")
        return
    endif

    "colorscheme colorzone
    "highlight StatusLine guibg=#DBDFD7
    "highlight TabLineFill guifg=#EFF0F1
    "return

    let g:W_color_scheme = a:color

    " 设置配色方案{{{
    " 还可以的 light 主题 {{{
    " biogoo
    " bmichaelsen
    " colorful
    " colorzone
    " d8g_02
    " nedit2
    " pspad
    " smp
    " soso
    " [*****] newspaper
    " [*****] peaksea
    " Tomorrow-Night-Eighties
    " PapayaWhip
    "
    " 暗色配色方案：
    " anotherdark
    " bubblegum
    " carvedwood
    " chance-of-storm
    " codeschool
    " corn
    " corporation
    " darkburn
    " darkz
    " dusk
    " freya
    " hybrid
    " lilypink
    " lucius
    " Monokai
    " mint
    " mrpink
    " neon
    " peaksea
    " pf_earth
    " phd
    " railscasts
    " rainbow_neon
    " rdark
    " selenitic
    " settlemyer
    " sonofobsidian
    " sorcerer
    " southwest-fog
    " spectro
    " strawimodo
    " tango2
    " tchaba
    " two2tango
    " vilight
    " void
    " vydark
    " watermark
    " wolfasm (only aviliable in rmbp)
    " wombat
    " zenburn
    " kellys
    " mrpink
    " kib_darktango
    " kolor
    " lilypink
    " liquidcarbon
    " lucius
    " manuscript
    " native
    " nazca
    " southwest-fog
    "}}}
    execute 'colorscheme ' . g:W_color_scheme
    let s:W_colorscheme_applied = 1
    "}}}

    " 调整配色方案{{{
    if &background == 'light'
        " 针对 light 类主题
        if g:W_color_scheme == "colorzone"
            hi Normal       guibg=#F2F2F3
            hi Special      guibg=#F2F2F3
            hi SpecialKey   guifg=#B7B8BA
            hi NonText      guifg=#F2F2F3 guibg=#F2F2F3
            hi StatusLine   guifg=white   guibg=#8F92E6
            hi StatusLineNR guifg=white   guibg=#CBE68F
            hi LineNr       guibg=#EAEAEB guifg=#157C10
            hi CursorLine   none
            hi CursorLine   guibg=#E0E0E1
            hi CursorLineNr guibg=#DBDBDC guifg=#157C10
            hi Visual       none
            hi Visual       term=reverse ctermbg=10 guibg=#DBDBDC
        endif
    elseif &background == 'dark'
        " 针对 dark 类主题
        if g:W_color_scheme == "solarized"
            "hi Normal   guibg=#00303C guifg=#A5C8C8
            hi Normal   guibg=#063946 guifg=#A5C8C8
            hi Comment  guifg=#6E7F96
            hi Folded   gui=bold
            hi Function  guifg=#5ED25C
            hi Statement guifg=#95C807
            hi PreProc   guifg=#D24B16
            hi cPreCondit guifg=#D24B16
            hi Type      guifg=#D29E00
            hi Constant  guifg=#64BEB5 guibg=#114350
            hi! link Special Constant
            hi helpHeader guifg=yellow
        elseif g:W_color_scheme == "gruvbox"
            hi cFunctions gui=bold guifg=#ffcc88 cterm=bold ctermfg=DarkBlue
            "hi Normal guibg=#303030
            hi String guibg=#373A17
            "hi Normal  guibg=#2D2C25
            "hi Normal  guibg=#252D2B
            hi Normal  guibg=#18261D
        elseif g:W_color_scheme == "neon"
            hi Folded  guibg=#003040 guifg=Grey
            hi Comment guifg=#909090
            hi NonText guibg=#282828
            "hi String guifg=#80BADF guibg=#2A3A45
        elseif g:W_color_scheme == "yeller"
            hi Normal   guibg=#16241B
            hi Function guifg=#73BD93
        elseif g:W_color_scheme == "two2tango"
            hi Normal   guibg=#122927
            hi NonText  guibg=#122927
        elseif g:W_color_scheme == "tango2"
            hi Normal       guibg=#414C5A
            hi LineNr       guibg=#424E5C
            hi Identifier   guifg=#1ECCEA
            "hi CursorLineNr guibg=#414C5A
            hi Statement    guifg=#7DB2DA
            hi shFunctionTwo guifg=#9BCF8D
            hi NonText      guifg=grey50
            hi SpecialKey   guifg=#485564
        endif

        if has("gui_running")
            let l:normal_bg = synIDattr(hlID("Normal"), "bg#", "gui")
            let l:normal_fg = synIDattr(hlID("Normal"), "fg#", "gui")

            " LineNr/CursorLineNr/CursorLine
            execute 'hi CursorLine   guibg=' . W_color_modify(l:normal_bg, 'add', 0x12)
            execute 'hi CursorLineNr guibg=' . W_color_modify(l:normal_bg, 'add', 0x12)
                                  \ 'guifg=' . W_color_modify(l:normal_fg, 'add', 0x10)
            execute 'hi LineNr       guibg=' . W_color_modify(l:normal_bg, 'add', 0x10)
                                  \ 'guifg=' . W_color_modify(l:normal_fg, 'sub', 0x20)

            " StatusLine/StatusLineNC
            execute 'hi StatusLine   gui=none'
                                  \ 'guibg=' . W_color_modify(l:normal_bg, 'add', 0x1D)
                                  \ 'guifg=' . W_color_modify(l:normal_bg, 'add', 0x88)
            execute 'hi StatusLineNC gui=none'
                                  \ 'guibg=' . W_color_modify(l:normal_bg, 'add', 0x10)
                                  \ 'guifg=' . W_color_modify(l:normal_bg, 'add', 0x70)

            execute 'hi VertSplit    guibg=' . W_color_modify(l:normal_bg, 'add', 0x1A)
                                  \ 'guifg=' . W_color_modify(l:normal_bg, 'add', 0x45)

            "execute 'hi Function     gui=bold'
            hi! link vimFunction Function
            execute 'hi Constant     guibg=' . W_color_modify(l:normal_bg, 'add', 0xA)

            " SpecialKey/Conceal
            " SpecialKey for chars setting by (:set listchars)
            execute 'hi SpecialKey gui=bold guibg=' . l:normal_bg
                      \ ' guifg=' . W_color_modify(l:normal_bg, 'add', 0x48)
            " Conceal for indentline plugin
            hi! link Conceal SpecialKey

            " Folded
            execute 'hi Folded guibg=' . W_color_modify(l:normal_bg, 'add', 0x20)

            " Pmenu/PmenuSel/ColorColumn
            "hi! link Pmenu LineNr
            "hi! link PmenuSel Cursor
            execute 'hi Pmenu gui=NONE guibg=' . W_color_modify(l:normal_bg, "add", 0x10)
                                    \ 'guifg=' . W_color_modify(l:normal_fg, 'sub', 0x25)
            execute 'hi PmenuSel guibg=' . W_color_modify(l:normal_bg, 'add', 0x25)
                              \ 'guifg=' . W_color_modify(l:normal_fg, 'add', 0x30)
            hi! link ColorColumn Pmenu

            " Visual
            hi Visual NONE
            execute 'hi Visual guibg=' . W_color_modify(l:normal_bg, 'add', 0x25)

            " TabLine/TabLineSel/TabLineFill
            let l:tmp_color = W_color_modify(l:normal_bg, 'add', 0x20)
            execute 'hi TabLine     gui=none guibg=' . l:tmp_color . ' guifg=' . l:normal_fg
            execute 'hi TabLineFill gui=none guibg=' . l:tmp_color . ' guifg=' . l:tmp_color
            execute 'hi TabLineSel  gui=bold guibg=' . l:normal_bg . ' guifg=#D2A458'

            " Search/Cursor
            "hi Search NONE
            "hi Search gui=reverse
            let l:tmp_color = synIDattr(hlID("String"), "fg#", "gui")
            if l:tmp_color != ""
                execute 'hi Search gui=NONE guifg=#222222 guibg=' . l:tmp_color
            endif
            hi Cursor NONE
            hi Cursor gui=reverse
        else
            hi Pmenu    ctermbg=0 ctermfg=7
            hi PmenuSel ctermbg=1 ctermfg=8

            hi Visual NONE
            hi Visual cterm=reverse term=reverse

            hi Search NONE
            hi Search term=reverse cterm=reverse

            hi Cursor NONE
            hi Cursor term=reverse cterm=reverse
        endif
    endif

    " }}}
    if s:W_TRUE == W_source("~wolfwzr/.vim/bundle/rainbow/plugin/rainbow.vim")
        RainbowLoad
    endif
endfunction
" }}}
" W_dict_qurey: 单词字典查询 {{{
function! W_dict_qurey(word)
    if a:word == ""
        return
    endif

    let l:tmp_file_prefix = "/tmp/vim_dict_"

    " 备份寄存器a
    let l:bakup_reg_a = @a

    if has("unix")
        " sdcv -n: 非交互模式
        let @a = system('sdcv -n --utf8-input --utf8-output '.a:word)
    else
        let @a = l:bakup_reg_a
        return
    endif

    let l:nr = bufwinnr(l:tmp_file_prefix . "*")
    if l:nr != -1
        execute nr . "wincmd w"
        normal ggVGd
    else
        " mktemp -u 只会生成文件名，不会创建文件
        execute "split" . system("mktemp -u ". l:tmp_file_prefix . "XXXXXXX")
    endif
    normal "ap

    nnoremap <buffer> q :q!<CR>
    nnoremap <buffer> <SPACE>
                \ :call W_dict_qurey('<C-r>=expand("<cword>")<CR>')<CR>
    nnoremap <buffer> <S-SPACE> <C-o>

    " 恢复寄存器a
    let @a = l:bakup_reg_a
endfunction
" }}}
" W_grep: grep in current buffer{{{
" Use Bgrep command(in Bgrep plugin) to grep with all buffers
function! W_grep(word)
    call setqflist([])
    "搜索当前buffer（未保存的也可以）
    silent execute "g/" . a:word . "/if &buftype == '' | call setqflist([{"
                 \ "'type': 'l', 'col':1, 'bufnr': winbufnr('.'), "
                 \ "'lnum': line('.'), 'text':getline('.')}], 'a') | endif"
    "execute "grepadd " . a:word . " " . %
    "botright cw
    belowright copen
endfunction
" }}}
" W_vundle_setting: Vundle及插件设置 {{{
function! W_vundle_setting()
    " ~/.vim/bundle/Vundle.vim/Vundle.vimrc
    " Vundle是一个管理插件的插件
    " 这里配置文件里面包含了各个插件的配置
    " source ~wolfwzr/.vim/bundle/Vundle.vim/Vundle.vimrc
    source ~wolfwzr/.vim/vundle.vimrc
endfunction
" }}}
" W_ft_c(){{{
function! W_ft_c()
    " 因为在cscope中跳转回来时打开的折叠又变为折叠，所以默认关闭折叠
    set foldmethod=syntax

    "setlocal cc=100
    "highlight WarningCols gui=undercurl
    "match WarningCols /\%>100v/

    call W_C_replace()

    runtime ftplugin/man.vim
    nnoremap K :Man <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M0 :Man 0 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M1 :Man 1 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M2 :Man 2 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M3 :Man 3 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M4 :Man 4 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M5 :Man 5 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M6 :Man 6 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M7 :Man 7 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M8 :Man 8 <C-r>=expand("<cword>")<CR><CR>
    nnoremap <Leader>M9 :Man 9 <C-r>=expand("<cword>")<CR><CR>

    call W_cscope_settings()

endfunction
" }}}
" W_ft_asm(){{{
function! W_ft_asm()
    set foldmethod=marker
    set commentstring=;%s

    setlocal syntax=nasm
    if has("gui_running")
        setlocal nolist
    endif
endfunction
" }}}
" W_ft_python(){{{
function! W_ft_python()
    set foldmethod=indent
    call W_cscope_settings()
endfunction
" }}}
" W_ft_help(){{{
function! W_ft_help()
    nnoremap <buffer> <CR> <C-]>
    nnoremap <buffer> <BS> <C-t>
    nnoremap <buffer> q    :q<CR>
    set ts=8
endfunction
" }}}
" W_ft_sh(){{{
function! W_ft_sh()
    set foldmethod=indent
    "call W_set_colorscheme("neon")
    inoremap { {}<Left>

    call W_cscope_settings()
endfunction
" }}}
" W_ft_vim(){{{
function! W_ft_vim()
    set foldmethod=marker
    iunmap "
    inoremap < <><Left>
    nnoremap <buffer> <Leader>h     :help <C-R>=expand("<cword>")<CR><CR>
    nnoremap <buffer> <F1>          :help <C-R>=expand("<cword>")<CR><CR>
    nnoremap <buffer> <S-F1>        :help <C-R>=expand("<cWORD>")<CR><CR>
    nnoremap <buffer> <C-LeftMouse> :help <C-R>=expand("<cword>")<CR><CR>
endfunction
" }}}
" W_ft_mkd(){{{
function! W_ft_mkd()
    setlocal foldenable
    setlocal nonu
    setlocal norelativenumber
    "call W_set_colorscheme("two2tango")

    nnoremap <buffer> <F5>  :!mkd_preview.sh %<CR>
    nnoremap <buffer> <C-t> :Toch<CR>
    nnoremap <buffer> o     A<CR>
endfunction
" }}}
" W_ft_qf(){{{
function! W_ft_qf()
    nnoremap <buffer> o             <CR>
    nmap     <buffer> <2-LeftMouse> <CR>
    nnoremap <buffer> p             <CR>:belowright copen<CR>
    nmap     <buffer> j             jp
    nmap     <buffer> k             kp
    nnoremap <buffer> q             :q<CR>
    nnoremap <buffer> <C-p>         :colder<CR>
    nnoremap <buffer> <C-n>         :cnewer<CR>
    "resize 15
endfunction
" }}}
" W_ft_man(){{{
function! W_ft_man()
    nmap     <buffer> <2-LeftMouse> <Leader>m
    nnoremap <buffer> q             :q<CR>
    setlocal ts=8
endfunction
" }}}

" }}}
" 专用函数 {{{
" W_InitMarkColor {{{
" 注意，将颜色定义放到当前 colorscheme.vim 中去
function! W_InitMarkColor()
    " 高亮的颜色，添加颜色时记得要更新s:syn_num的初始值"
    hi W_MarkWord0  ctermbg=Cyan    ctermfg=Black guibg=#EA8E8E guifg=Black
    hi W_MarkWord1  ctermbg=Green   ctermfg=Black guibg=#8EEAEA guifg=Black
    hi W_MarkWord2  ctermbg=Yellow  ctermfg=Black guibg=#EABC8E guifg=Black
    hi W_MarkWord3  ctermbg=Red     ctermfg=Black guibg=#8EBCEA guifg=Black
    hi W_MarkWord4  ctermbg=Magenta ctermfg=Black guibg=#EAEA8E guifg=Black
    hi W_MarkWord5  ctermbg=Blue    ctermfg=White guibg=#8E8EEA guifg=Black
    hi W_MarkWord6  ctermbg=Cyan    ctermfg=Black guibg=#BCEA8E guifg=Black
    hi W_MarkWord7  ctermbg=Green   ctermfg=Black guibg=#BC8EEA guifg=Black
    hi W_MarkWord8  ctermbg=Yellow  ctermfg=Black guibg=#8EEA8E guifg=Black
    hi W_MarkWord9  ctermbg=Red     ctermfg=Black guibg=#EA8EEA guifg=Black
    hi W_MarkWord10 ctermbg=Magenta ctermfg=Black guibg=#8EEABC guifg=Black
    hi W_MarkWord11 ctermbg=Blue    ctermfg=White guibg=#EA8EBC guifg=Black

    "hi W_MarkWord0 ctermbg=Cyan    ctermfg=Black guibg=#8CCBEA guifg=Black
    "hi W_MarkWord1 ctermbg=Green   ctermfg=Black guibg=#A4E57E guifg=Black
    "hi W_MarkWord2 ctermbg=Yellow  ctermfg=Black guibg=#FFDB72 guifg=Black
    "hi W_MarkWord3 ctermbg=Red     ctermfg=Black guibg=#FF7272 guifg=Black
    "hi W_MarkWord4 ctermbg=Magenta ctermfg=Black guibg=#FFB3FF guifg=Black
    "hi W_MarkWord5 ctermbg=Blue    ctermfg=White guibg=#9999FF guifg=Black
endfunction
"}}}

" W_mark: 高亮单词，用于替换Mark插件（Mark插件性能不行）{{{
function! W_mark(str, is_a_word)
    let l:default="__XXX_wzr_not_found_XXX__"
    let l:id=0

    if s:W_TRUE == a:is_a_word
        let l:pat = '\<' . a:str . '\>'
    else
        let l:pat = a:str
    endif

    "let l:cur_syn = synIDattr(synID(line("."), col("."), 1), "name")
    "if 0 == match(l:cur_syn, "W_MarkWord")
    "    execute 'match none /\<' . a:str . '\>/'
    "execute "match " . l:group . " /" . l:pat . "/"
    if has_key(s:W_MarkColorPattern, l:pat)
       let l:id = get(s:W_MarkColorPattern, l:pat, l:default)
       if l:default != l:id
            call matchdelete(l:id)
            call remove(s:W_MarkColorPattern, l:pat)
       endif
    else " Choose a color and mark a:str
        let s:W_last_mark_idx = (s:W_last_mark_idx + 1) % s:syn_num
        let l:group = 'W_MarkWord' . s:W_last_mark_idx
        let s:W_MarkColorPattern[l:pat] = matchadd(l:group, l:pat)
    endif
endfunction
" }}}
" W_code_common_setting: 代码通用设置 {{{
function! W_code_common_setting()
    syntax on
    set cindent
    set tabstop=4
    set shiftwidth=4
    set expandtab
    set nofoldenable

    set cursorline
    "set colorcolumn=100

    " 显示特殊字符
    set list
    "set listchars=tab:\|\ ,trail:-,nbsp:%
    set listchars=tab:\|\ ,trail:•,nbsp:%
    " 警示行尾多余空格
    " match Error /\s\+$/
    " 显示缩进垂直对齐线
    "call W_exec_cmd("IndentLinesEnable")

    " 按<Leader><Leader>执行make并打开quickfix窗口
    " 然后跳到第一个错误处(如果有错误的话)
    "nnoremap <Leader><SPACE> :make<CR><CR>:cw<CR>:cc<CR>

    " 将选中的代码按 '=' 对齐
    vnoremap <Leader>= :Tabularize /=<CR>

    " 快速插入函数注释头
    command! Ifc call W_insert_function_header('cn')
    command! Ife call W_insert_function_header('en')
    " 不知道为什么会多输出一个0,所以用<BS>删除
    "inoremap <Leader>ifc <C-r>=W_insert_function_header('cn')<CR><BS><C-o>A
    "inoremap <Leader>ife <C-r>=W_insert_function_header('en')<CR><BS><C-o>A

    call W_common_replace()

    "light colorscheme
    "set background=light
    "call W_set_colorscheme("colorzone")

    "dark colorscheme
    set background=dark
    "call W_set_colorscheme("tango2")
    call W_set_colorscheme("solarized")
endfunction
"}}}
" W_C_replace: C语言自动替换 {{{
function! W_C_replace()

    inoremap { {<CR>}<Esc>O

    " 考虑到({等符号已成对匹配，以下替换也做了相应修改
    "iabbrev iff if ()<CR>{<CR>}<Esc>kk$i<C-r>=W_eatchar(' ')<CR>
    "iabbrev elsee else<CR>{<CR>}<Esc>O<C-r>=W_eatchar(' ')<CR>
    "iabbrev whilee while ()<CR>{<CR>}<Esc>kk$i<C-r>=W_eatchar(' ')<CR>
    "iabbrev fore for ()<CR>{<CR>}<Esc>kk$i<C-r>=W_eatchar(' ')<CR>
    "iabbrev doo do<CR>{<CR>}<CR>while ();<Left><Left><C-r>=W_eatchar(' ')<CR>

    iabbrev iff if (<C-o>o{<Esc>ddkk$i<C-r>=W_eatchar(' ')<CR>
    iabbrev forr for (<C-o>o{<Esc>ddkk$i<C-r>=W_eatchar(' ')<CR>
    iabbrev whilee while (<C-o>o{<Esc>ddkk$i<C-r>=W_eatchar(' ')<CR>
    iabbrev doo do<CR>{<Esc>ddowhile (<Right>;<Left><Left><C-r>=W_eatchar(' ')<CR>
    iabbrev elsee else<CR>{<C-r>=W_eatchar('')<CR>

    iabbrev inc #include <.h><Left><Left><Left><C-r>=W_eatchar(' ')<CR>
endfunction
" }}}
" W_insert_function_header: {{{
function! W_insert_function_header(lang)
    let b:reg_bakup = @a
    "中文版{{{
    if a:lang == 'cn'
        let @a="
\/*************************************************************************\n
\ 函数名称: \n
\ 功能描述: \n
\ 输入参数: \n
\ 输出参数: \n
\ 返 回 值: \n
\ ------------------------------------------------------------------------\n
\ 最近一次修改记录:\n
\ 修改作者: wangzhengrong\n
\ 修改目的: 定义函数\n
\ 修改日期: "
    "}}}
    "英文版{{{
    elseif a:lang == 'en'
        let @a="
\/*************************************************************************\n
\ Name        : \n
\ Function    : \n
\ Input Args  : \n
\ Output Args : \n
\ Return Value: \n
\ ------------------------------------------------------------------------\n
\ Lastest Modify Record:\n
\ Author : wangzhengrong\n
\ Purpose: create function\n
\ Date   : "
    endif
    "}}}
    normal "ap10j
    execute 'r!date +\%F'
    normal kJ
    let @a="
\*************************************************************************/\n"
    normal "ap10k$
    let @a = b:reg_bakup
endfunction
"}}}
" W_cscope_init_db: init cscope database {{{
function! W_cscope_init_db()
    let l:cwd_bakup = fnameescape(getcwd())
    let l:tmp_dir = ''
    let l:find_db = 0

    " kill all connections
    cs kill -1

    " search the first database from current directory up to '/'
    " load the database and change CWD to that directory
    while l:tmp_dir != '/'
        let l:tmp_dir = fnameescape(getcwd())
        if isdirectory(l:tmp_dir)
            if filereadable(l:tmp_dir . '/cscope.out')
                cs add ./cscope.out
                let l:find_db = 1
                break
            endif
        else
            break
        endif
        " go to parrent directory
        if isdirectory(l:tmp_dir . '/..')
            execute 'cd ' . l:tmp_dir . '/..'
        endif
    endwhile

    if find_db == 0
        " go to origin directory if no database found
        if isdirectory(l:tmp_dir . '/..')
            execute 'cd ' . l:cwd_bakup
        endif
        if $CSCOPE_DB != ""
            " add database pointed to by environment
            cs add $CSCOPE_DB
        endif
    endif
endfunction
" }}}
" W_cscope_update_db: update cscope database {{{
function! W_cscope_update_db()
    call system('cscope -Rbq')
    cs reset
endfunction
" }}}
" W_cscope_init: 初始化cscope {{{
" See more:
"   :help cscope
"   http://vim.wikia.com/wiki/Cscope
function! W_cscope_init()
    if ! has("cscope")
        return
    endif

    "set csprg=/usr/bin/cscope
    set csprg=cscope
    set csto=0
    set cst
    " '+' indicates that results must be appended to quickfix window,
    " '-' implies previous results clearance, '0' or command absence - don't use quickfix
    set cscopequickfix=s-,c-,d-,i-,t-,e-
    "set cscopequickfix=s+,c+,d+,i+,t+,e+

    set nocsverb
    call W_cscope_init_db()
    set csverb

    nnoremap <Leader>fg zz:cs find g <C-R>=expand("<cword>")<CR><CR>zz
    nnoremap <Leader>ff :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nnoremap <Leader>fs :cs find s <C-R>=expand("<cword>")<CR><CR><C-o>:belowright copen<CR>
    nnoremap <Leader>r  :cs find s <C-R>=expand("<cword>")<CR><CR><C-o>:belowright copen<CR>
    nnoremap <Leader>fc :cs find c <C-R>=expand("<cword>")<CR><CR><C-o>:belowright copen<CR>
    nnoremap <Leader>ft :cs find t <C-R>=expand("<cword>")<CR><CR><C-o>:belowright copen<CR>
    nnoremap <Leader>fe :cs find e <C-R>=expand("<cword>")<CR><CR><C-o>:belowright copen<CR>
    nnoremap <Leader>fi :cs find i <C-R>=expand("<cfile>")<CR><CR><C-o>:belowright copen<CR>
    nnoremap <Leader>fd :cs find d <C-R>=expand("<cword>")<CR><CR><C-o>:belowright copen<CR>

    " show result in new window
    nnoremap <Leader>fS :split<CR>:cs find s <C-R>=expand("<cword>")<CR><CR>
    nnoremap <Leader>fG :split<CR>:cs find g <C-R>=expand("<cword>")<CR><CR>
    nnoremap <Leader>fC :split<CR>:cs find c <C-R>=expand("<cword>")<CR><CR>
    nnoremap <Leader>fT :split<CR>:cs find t <C-R>=expand("<cword>")<CR><CR>
    nnoremap <Leader>fE :split<CR>:cs find e <C-R>=expand("<cword>")<CR><CR>
    nnoremap <Leader>fF :split<CR>:cs find f <C-R>=expand("<cfile>")<CR><CR>
    nnoremap <Leader>fI :split<CR>:cs find i <C-R>=expand("<cfile>")<CR><CR>
    nnoremap <Leader>fD :split<CR>:cs find d <C-R>=expand("<cword>")<CR><CR>

    nnoremap <Leader>fu :call W_cscope_update_db()<CR>
    nnoremap <Leader>fl :call W_cscope_init_db()<CR>
    nnoremap <F5>       :call W_cscope_update_db()<CR>

    command! -nargs=1 Css cs find s <args>
    command! -nargs=1 Csg cs find g <args>
    command! -nargs=1 Csc cs find c <args>
    command! -nargs=1 Cst cs find t <args>
    command! -nargs=1 Cse cs find e <args>
    command! -nargs=1 Csf cs find f <args>
    command! -nargs=1 Csi cs find i <args>
    command! -nargs=1 Csd cs find d <args>

    command! Csu call W_cscope_update_db()
    command! Csl call W_cscope_init_db()
endfunction
" }}}
" W_cscope_lookup_define_or_symbol: 使用cscope查询定义或符号{{{
" 使用 cscope 查询，先查询符号定义，若查到则跳到定义处，
" 若没有查到，则查询符号引用处并跳到第一个引用的地方。
function! W_cscope_lookup_define_or_symbol(pattern)
    normal :<Esc>
    let l:msg_bakup = v:errmsg
    let v:errmsg = ""
    execute "silent! cs find g " . a:pattern
    if v:errmsg == ""
        normal <C-t>
        execute "cs find g " . a:pattern
        let v:errmsg = l:msg_bakup
    else
        let s:W_cscope_is_from_symbol = s:W_TRUE
        execute "cs find s " . a:pattern
    endif
endfunction
"}}}
" W_cscope_back: 针对W_cscope_lookup_define_or_symbol函数的返回{{{
function! W_cscope_back()
    if s:W_cscope_is_from_symbol == s:W_TRUE
        execute "normal \<C-o>"
        let s:W_cscope_is_from_symbol = s:W_FALSE
    else
        execute "normal \<C-t>"
    endif
endfunction
" }}}
" W_cscope_settings {{{
function! W_cscope_settings()

    call W_cscope_init()

    "nnoremap <buffer> <CR>
    "    \ :call W_cscope_lookup_define_or_symbol('<C-R>=expand("<cword>")<CR>')<CR>
    "nnoremap <buffer> <C-LeftMouse>
    "    \ :call W_cscope_lookup_define_or_symbol('<C-R>=expand("<cword>")<CR>')<CR>
    "nnoremap <buffer> <Leader>b :call W_cscope_back()<CR>
    nmap <buffer> <CR> <Leader>fg
    nmap <buffer> <BS> <C-t>zz
    nnoremap <buffer> <S-CR>    :Csg .*.*<Left><Left>
    nnoremap <buffer> <C-CR>    :Csg <C-r>+<CR>

    " remove auto_cd group
    autocmd! auto_cd
endfunction
"}}}

" W_auto_set_window_size: 自动根据内容设置窗口大小{{{
function! W_auto_set_window_size()
    " get line: head -n 50 | wc -l
    " get maxwidth: wc -L

    let l:cmd_output = system("head -n 40 \"" . bufname("%") . "\" | wc -l | xargs -I {} echo -n {}")
    "echom "lines: " . l:cmd_output
    if l:cmd_output < 20
        let l:cmd_output = 20
    endif
    let l:cmd_output += 4
    if &lines != l:cmd_output
        execute "set lines=" . l:cmd_output
    endif

    let l:cmd_output = system("head -n 100000 \"" . bufname("%") . "\" | wc -L | xargs -I {} echo -n {}")
    "echom "columns: " . l:cmd_output
    if l:cmd_output < 70
        let l:cmd_output = 70
    endif
    if l:cmd_output > 130
        let l:cmd_output = 130
    endif
    let l:cmd_output += 10
    if &columns != l:cmd_output
        execute "set columns=" . l:cmd_output
    endif

    "if has("unix") && ! has("macunix")
    "    execute "silent !center-current-window.sh"
    "endif
endfunction
" }}}
" }}}

call W_vundle_setting()
call W_basic_setting()
call W_shortcut_setting()
call W_gui_setting()

augroup auto_cd
    autocmd BufEnter * cd %:p:h
augroup end

augroup wolfwzr_autocmd
    autocmd BufRead,BufNewFile *.bashrc             set filetype=sh
    autocmd BufRead,BufNewFile *.bochsrc            set filetype=bochs
    autocmd BufRead,BufNewFile *.vimrc              set filetype=vim
    autocmd BufRead,BufNewFile *.wsgi               set filetype=python
    autocmd BufRead,BufNewFile *.{md,mkd,markdown}  set filetype=mkd

    " 打开文件时恢复光标位置
    autocmd BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \   exe "normal g`\"" |
        \ endif

    " CommandLine Windows <CR>可以被映射成其它用途了，所以使用'o'来执行命令
    autocmd CmdWinEnter : nnoremap <buffer> o <CR>

    autocmd FileType c,cpp,h,asm,vim,mkd,conf,sh,python,html,xml,css,js,xsl,xslt,flex,bison,yacc
        \ call W_code_common_setting()
    autocmd FileType c,cpp,h,flex,bison,yacc,asm,nasl call W_ft_c()
    autocmd FileType sh     call W_ft_sh()
    autocmd FileType help   call W_ft_help()
    autocmd FileType vim    call W_ft_vim()
    autocmd FileType mkd    call W_ft_mkd()
    autocmd FileType qf     call W_ft_qf()
    autocmd FileType man    call W_ft_man()
    autocmd FileType python call W_ft_python()
augroup end

" more gui settings (after this config file):
"   /usr/local/Cellar/macvim/7.4-88/MacVim.app/Contents/Resources/vim/gvimrc

" vim: set ft=vim:
